# Лабораторная работа по АК №3
- Ситкевич Валерий Андреевич, P33121
- `lisp | acc | harv | hw | instr | struct | stream | port | prob1`

## Язык программирования

- Синтаксис - S-expressions. Любое выражение -- expression
- В S-expressions сначала вычисляется первый аргумент, потом второй, а потом сама функция
- Переменные имеют глобальную область видимости
- Язык имеет динамическую типизацию

### Синтаксис языка lisp
Синтаксис языка Лисп в форме Бэкуса — Наура определяется следующим образом:
``` ebnf
program ::= s-expression* comment
comment ::= ";" <any symbols>
s_expression ::= atom / list
list ::= "(" function args ")"
function ::= "setq" / "read" / "print" / "loop" / "if" / "return" 
    / "+" / "-" / ">" / "<" / "=" / "mod"
args ::= s_expression s_expression s_expression
atom ::= empty / word / number / var_name

word ::= '"' [a-z A-Z 1-9 \s]+ '"'
var_name ::= [a-zA-Z1-9]+
number ::= [-]?[0-9]+
empty ::=             
```

## Организация памяти

- Переменные и константы определяются через setq
- Виды адресации: прямая абсолютная, косвенная, прямая загрузка
- Память команд. Реализуется списком словарей, описывающих инструкции (одно слово -- одна ячейка).
- Память данных. Линейное адресное пространство. Реализуется списком чисел.
- В памяти данных сначала хранятся строки, затем буферы размером 100 ячеек, в которые сохраняется ввод, потом переменные с константами (у каждой переменной 2 ячейки, 1я - тип переменной числом, 2я - сама переменная), в конце промежуточные результаты выполнения.

```text
   Instruction memory
+---------------------------------------+
| 00  : load 1st char of 1st string     |
| 01  : push it                         |
| 02  : load 2nd char of 1st string     |
| 03  : push it                         |
|    ...                                |
| n   : program start                   |
|    ...                                |
+---------------------------------------+


     Data memory
+---------------------------------------+
|    Строки                             |
+---------------------------------------+
| 00        : 1st char of 1st string    |  
| 01        : 2nd char of 1st string    |
|    ...                                |
| n         : last char of 1st string   |
| n + 1     : 0                         |
| n + 2     : 1st char of 2nd string    |
|    ...                                |
| m - 2     : last char of n string     |
| m - 1     : 0                         |
+---------------------------------------+
|    Буферы ввода                       |
+---------------------------------------+
| m         : 1st read buffer           |
|    ...                                |
| m + 100   : 2nd read buffer           |
|    ...                                |
| m + 100*k : n read buffer             |
|    ...                                |
+---------------------------------------+
|    Переменные и константы             |
+---------------------------------------+
| v         : type of var1              |
| v+1       : var1                      |
| v+2       : type of var2              |
| v+3       : var2                      |
|    ...                                |
+---------------------------------------+
|    Промежуточные результаты           |
+---------------------------------------+
| t         : type of temp var1         |
| t + 1     : temp var1                 |
|    ...                                |
+---------------------------------------+
```

## Архитектура набора команд
Аккумуляторная архитектура. Все операции - однооперандные - всегда применяются к значению в аккумуляторе
- `load addr` -- загрузка значения ячейки по адресу addr в аккумулятор 
- `loadc const` -- прямая загрузка константы в аккумулятор 
- `mem addr` -- загрузка значения в аккумулятор через косвенную адресацию
- `store addr` -- сохранение аккумулятора по адресу
- `store_mem addr` -- сохранение аккумулятора через косвенную адресацию
- `add addr` -- добавление в аккумулятор значения из ячейки
- `addc const` -- добавление в аккумулятор константы
- `sub addr` -- вычитание из аккумулятора значения из ячейки
- `print` -- вывод в поток символа из аккумулятора
- `print_int` -- вывод в поток числа из аккумулятора
- `read` -- чтение символа в аккумулятор из потока ввода
- `jmp addr` -- безусловный переход на терм
- `je addr` -- переход на терм при ACC==0
- `jne addr` -- переход на терм при ACC!=0
- `jg addr` -- переход на терм при ACC>0
- `jl addr` -- переход на терм при ACC<0
- `halt` -- завершение выполнения программы

### Кодирование инструкций

- Машинный код сериализуется в список JSON.
- Индекс списка -- адрес инструкции. Используется для команд перехода.

Пример:

```json
[
    {
        "opcode": "loadc",
        "arg": 1050,
        "term": 0
    }
]
```
## Транслятор Lisp
Этапы трансляции:
text → [reader] → [evaluator] → opcodes

Reader принимает на вход текст программы, удаляет комментарии, преобразует loop for в loop и возвращает s-expressions.
Evaluator принимает s-expressions и преобразует их в машинный код.
